# 1, 7, 13. Описать регулярными выражениями все десятичные целые числа,
# которые делятся на 2, на 4, на 8. Построить диаграммы минимального ДКА. 
# Числа могут начинаться с незначащих нулей, не могут быть пустой строкой.

mod 2: /^[0-9]*[02468]$/

    0 1 2 3 4 5 6 7 8 9
0~  0 1 0 1 0 1 0 1 0 1
1   0 1 0 1 0 1 0 1 0 1

Минимальность очевидна: одно - финальное, другое - нет.

mod 4: /^[0-9]*((^|[02468])[048]|[13579][26])$/

    0 1 2 3 4 5 6 7 8 9
0~  0 1 2 3 0 1 2 3 0 1
1   2 3 0 1 2 3 0 1 2 3
2   0 1 2 3 0 1 2 3 0 1
3   2 3 0 1 2 3 0 1 2 3

Можно объединить 1 и 3, т.к. строки одинаковые.

    0 1 2 3 4 5 6 7 8 9
0~  0 1 2 1 0 1 2 1 0 1
1   2 1 0 1 2 1 0 1 2 1
2   0 1 2 1 0 1 2 1 0 1

Минимальный.

mod 8:
~abc~ = 100a + 10b + c ~ 4a + 2b + c (8)

4i 2i i | 4a        + 2b    + c     ~ 0 (8)
0  0  0 | 0:[02468] 0:[048] 0:[08]
4  2  1 |           2:[159] 6:6
0  4  2 |           4:[26]  4:4
4  6  3 |           6:[37]  2:2
0  0  4 | 4:[13579] 0:[048] 4:4
4  2  5 |           2:[159] 2:2
0  4  6 |           4:[26]  0:[08]
4  6  7 |           6:[37]  6:6
0  0  8 |
4  2  9 |

mod 8: /^[0-9]*(
    (^|[02468])(
        (^|[048])[08]
        |[159]6
        |[26]4
        |[37]2
    )
    |[13579](
        [048]4
        |[159]2
        |[26][08]
        |[37]6
    )
)$/

mod 8: /^[0-9]*((^|[02468])((^|[048])[08]|[159]6|[26]4|[37]2)|[13579]([048]4|[159]2|[26][08]|[37]6))$/

    0 1 2 3 4 5 6 7 8 9
0~  0 1 2 3 4 5 6 7 0 1
1   2 3 4 5 6 7 0 1 2 3
2   4 5 6 7 0 1 2 3 2 3
3   6 7 0 1 2 3 2 3 4 5
4   0 1 2 3 4 5 6 7 0 1
5   2 3 4 5 6 7 0 1 2 3
6   4 5 6 7 0 1 2 3 2 3
7   6 7 0 1 2 3 2 3 4 5

Аналогично mod 4, можно объединить: 1-5, 2-6, 3-7.

    0 1 2 3 4 5 6 7 8 9
0~  0 1 2 3 4 1 2 3 0 1
1   2 3 4 1 2 3 0 1 2 3
2   4 1 2 3 0 1 2 3 2 3
3   2 3 0 1 2 3 2 3 4 1
4   0 1 2 3 4 1 2 3 0 1

Минимальный.

# 2, 8. Построить диаграмму минимального конечного автомата, принимающего десятичные
# числа от 0 до 65535. Число может начинаться с незначащих нулей, не может быть
# пустой строкой.
# Принимаемые числа: 0, 007, 6666, 9999, 0000065535.
# Не принимаемые числа: 999999, 65536, 66666.

Не число - сразу fail, хотите - обрабатывайте отдельно

    0 1 2 3 4 5 6 7 8 9
n   s 4 4 4 4 4 a 3 3 3
s~  s 4 4 4 4 4 a 3 3 3
a~  3 3 3 3 3 b 2 2 2 2
b~  2 2 2 2 2 c 1 1 1 1
c~  1 1 1 d 0 0 0 0 0 0
d~  0 0 0 0 0 0 f f f f
4~  3 3 3 3 3 3 3 3 3 3
3~  2 2 2 2 2 2 2 2 2 2
2~  1 1 1 1 1 1 1 1 1 1
1~  0 0 0 0 0 0 0 0 0 0
0~  f f f f f f f f f f
f   f f f f f f f f f f

Все строки различны - минимальный.

# 3, 9. Построить диаграмму минимального конечного автомата, принимающего числа,
# делящиеся на 2, на 3, на 6. Число может начинаться с незначащих нулей,
# не может быть пустой строкой.

mod 2:
    0 1 2 3 4 5 6 7 8 9
0~  0 1 0 1 0 1 0 1 0 1
1   0 1 0 1 0 1 0 1 0 1

mod 3:
    0 1 2 3 4 5 6 7 8 9
0~  0 1 2 0 1 2 0 1 2 0
1   1 2 0 1 2 0 1 2 0 1
2   0 1 2 0 1 2 0 1 2 0

mod 6:
    0 1 2 3 4 5 6 7 8 9
0~  0 1 2 3 4 5 0 1 2 3
1   4 5 0 1 2 3 4 5 0 1
2   2 3 4 5 0 1 2 3 4 5
3   0 1 2 3 4 5 0 1 2 3
4   4 5 0 1 2 3 4 5 0 1
5   2 3 4 5 0 1 2 3 4 5

Можно объединить 1-4, 2-5

    0 1 2 3 4 5 6 7 8 9
0~  0 1 2 3 1 2 0 1 2 3
1   1 2 0 1 2 3 1 2 0 1
2   2 3 1 2 0 1 2 3 1 2
3   0 1 2 3 4 2 0 1 2 3

# 4, 10. Записать регулярное выражение для строки в двойных кавычках с
# escape-последовательностями языка C89. Построить для него диаграмму конечного
# автомата.
# Для справки: https://ru.cppreference.com/w/cpp/language/escape
# (C89 не поддерживал \u и \U, их не надо).

C89: /^"([^\\]|\\['"?\\0abfnrtv]|\\[0-7]{3}|\\x[0-9a-fA-F]{2})*"$/

    "   \\  0   [abf]   [?nrtv] [1-7]   [89cdeA-F]  x   .
in  s   f   f   f       f       f       f           f   f
s   e   p   s   s       s       s       s           s   s
p   s   s   s   s       s       o1      f           x1  f
o1  f   f   o2  f       f       o2      f           f   f
o2  f   f   s   f       f       s       f           f   f
x1  f   f   x2  x2      f       x2      x2          f   f
x2  f   f   s   s       f       s       s           f   f
e~  f   f   f   f       f       f       f           f   f
f   f   f   f   f       f       f       f           f   f

# 5, 11. Язык состоит из целых и вещественных десятичных чисел, разделённых пробельными
# символами. Десятичным разделителем является точка. Следует описать его лексическую
# структуру и построить лексический распознаватель.
# Правильные целые числа: 3, 30, 1234567890987654321, +1, -0.
# Правильные вещественные числа: 6.022e23, +6.022e+23, 1.38e-23, 8.31, 3e8, -273.15.
# Неправильные вещественные числа: .33e7 (нет цифры перед точкой), 20. (нет цифры
# после точки), e10 (нет мантиссы), e2e4.

/^[+-]?\d+(\.\d+)?(e[+-]?\d+)?$/

    \d  \.  e   [+-]
0   2   f   f   1
1   2   f   f   f
2~  2   3   5   f
3   4   f   f   f
4~  4   f   5   f
5   7   f   f   6
6   7   f   f   f
7~  7   f   f   f
f   f   f   f   f

# 6, 12. Язык состоит из целочисленных констант языка ассемблера (синтаксис MASM),
# требуется записать его лексическую структуру и построить лексический распознаватель.
# Десятичные константы — последовательности десятичных цифр, которые
# заканчиваются на необязательный знак d.
# Шестнадцатеричные константы — последовательности шестнадцатеричных цифр,
# начинающихся на десятичную цифру и заканчивающиеся на h.
# Восьмеричные константы — последовательности восьмеричных цифр,
# заканчивающихся на знак q.
# Двоичные константы — последовательности двоичных цифр, заканчивающихся на b.
# Для справки: https://prog-cpp.ru/asm-datatypes/.

/^[0-9]+d?|[0-9][0-9A-F]*h|[01]+b|[0-7]+[qo]$/

    [01]    [2-7]   [89]    [A-F]   d   h   b   [qo]
0   1       2       3       f       f   f   f   f
1~  1       2       3       4       e   e   e   e
2~  2       2       3       4       e   e   f   e
3~  3       3       3       4       e   e   f   f
4   4       4       4       4       f   e   f   f
e~  f       f       f       f       f   f   f   f
f   f       f       f       f       f   f   f   f
